* Dependent Types
A dependent type is *a type that is defined by something that is not a type*.

** Induction on Natural Numbers
 - Induction involves a proof of N=0, then of N+1
 - In Pie, induction on Nat uses the form =ind-Nat=
 - =ind-Nat= can do everything =rec-Nat= can do, plus work with dependent types
 - =ind-Nat= takes an extra argument between the target and the base called the motive
 - The motive is a function that returns the type of the expression at every step
   - this includes the base step
   - this means the motive determines the type of the =ind-Nat= expression as a whole

#+begin_example

(ind-Nat target
  motive
  base
  step)

#+end_example

We said above that =ind-Nat= behaves like =rec-Nat= except that we can use it
with dependent types. This means that base and step return different dependent
types. The arguments to =ind-Nat= are:

- =target= : the initial =Nat=
- =motive= : a function that is applied to the target at each step to
  determine the type returned by that step, or the base when the
  target is =zero=
- =base= : the value to return when the =target= is =zero=
- =step= : a function that accepts the value under the =add1= and the
  recursive result of the computation at that step. The value of the
  final (top-most) =step= is the value of the =ind-Nat= expression.

The workings of =ind-Nat= are best illustrated by example.

** Exercises

Suppose want to define a function that returns a specific number of =’peas=. We
could define the function to return a =(List Atom)= like this:

#+begin_src racket :tangle list-of-peas.rkt :lang pie

#lang pie

(claim step-list-of-peas
  (-> Nat (List Atom)
      (List Atom)))

(define step-list-of-peas
  (lambda (k-1 answer-k-1)
    (:: 'pea answer-k-1)))

(claim list-of-peas
  (-> Nat (List Atom)))

(define list-of-peas
  (lambda (k)
    (rec-Nat k
      (the (List Atom) nil)
      step-list-of-peas)))

(check-same (List Atom)
  (:: 'pea nil)
  (list-of-peas 1))

(check-same (List Atom)
  (the (List Atom) nil)
  (list-of-peas 0))

#+end_src

Using a list works in this case, but is unsatisfying because the type doesn’t
describe /how many/ peas are returned. What if we modify the code to use a
Vector instead?

#+begin_src racket :tangle failed-attempt.rkt :lang pie

#lang pie

(claim vec-of-peas
  (Π ((k Nat))
     (Vec Atom k)))

(define vec-of-peas
  (λ (k)
    (rec-Nat k
      (the (Vec Atom zero) vecnil)
      (λ (k-1 ans-k-1)
        (the (Vec Atom (add1 k-1))
             (vec:: 'pea ans-k-1))))))

#+end_src

This definition /seems/ like it should work, but results in an error because
=rec-Nat= isn’t able to work with dependent types. Now we can see how =ind-Nat=
allows us to specify the different specific types returned by the base and each
step.

#+begin_src racket :tangle yes :lang pie
  #lang pie

  (claim motive-peas
    (Π ((l Nat))
       U))

  (define motive-peas
    (λ (l)
      (Vec Atom l)))

  (claim step-peas
    (Π ((l-1 Nat))
       (-> (motive-peas l-1)
           (motive-peas (add1 l-1)))))

  (define step-peas
    (λ (l-1)
      (λ (answer-l-1)
        (vec:: 'pea answer-l-1))))

  (claim peas
    (Π ((l Nat))
       (Vec Atom l)))

  (define peas
    (λ (l)
      (ind-Nat l
        motive-peas
        vecnil
        step-peas)))

  (check-same
   (Vec Atom 5)
   (the (Vec Atom 5)
        (vec:: 'pea
               (vec:: 'pea
                      (vec:: 'pea
                             (vec:: 'pea
                                    (vec:: 'pea vecnil))))))
   (peas 5))
#+end_src

Here’s another exercise. Let’s write the =last= function, which returns the last
element of a vector of any type. /TODO/: work through this example step by step.

#+begin_src racket :lang pie :tangle yes
  (claim motive-last
    (-> U Nat
        U))

  (define motive-last
    (λ (E k)
      (-> (Vec E (add1 k))
          E)))

  (claim base-last
    (Π ((E U))
       (-> (Vec E (add1 zero))
           E)))

  (define base-last
    (λ (E)
      (λ (es)
        (head es))))

  (claim step-last
    (Π ((E U)
        (k Nat))
       (-> (-> (Vec E (add1 k)) E)
           (-> (Vec E (add1 (add1 k)))
               E))))

  (define step-last
    (λ (E)
      (λ (n-1 last-of-n-1)
        (λ (es)
          (last-of-n-1 (tail es))))))

  (claim last
    (Π ((E U)
        (k Nat))
       (-> (Vec E (add1 k))
           E)))

  (define last
    (λ (E k)
      (λ (es)
        ((ind-Nat k
           (motive-last E)
           (base-last E)
           (step-last E)) es))))

  (check-same
   Atom
   'Done
   (last Atom 0 (vec:: 'Done vecnil)))

  (check-same
   Atom
   'Coming
   (last Atom 2 (vec:: 'Winter (vec:: 'Is (vec:: 'Coming  vecnil)))))
#+end_src
