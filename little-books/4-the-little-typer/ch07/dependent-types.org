#+TITLE: Dependent Types
#+OPTIONS: toc:nil num:nil author:nil timestamp:nil
#+EXPORT_FILE_NAME: index.html
* Definition
A dependent type is *a type that is defined by something that is not a type*.

* Induction on Natural Numbers
 - Induction involves a proof of N=0, then of N+1
 - In Pie, induction on Nat uses the form =ind-Nat=
 - =ind-Nat= can do everything =rec-Nat= can do, plus work with dependent types
 - =ind-Nat= takes an extra argument between the target and the base called the motive
 - The motive is a function that returns the type of the expression at every step
   - this includes the base step
   - this means the motive determines the type of the =ind-Nat= expression as a whole

#+begin_example

(ind-Nat target
  motive
  base
  step)

#+end_example

We said above that =ind-Nat= behaves like =rec-Nat= except that we can use it
with dependent types. This means that base and step return different dependent
types. The arguments to =ind-Nat= are:

- =target= : the initial =Nat=
- =motive= : a function that is applied to the target at each step to
  determine the type returned by that step, or the base when the
  target is =zero=
- =base= : the value to return when the =target= is =zero=
- =step= : a function that accepts the value under the =add1= and the
  recursive result of the computation at that step. The value of the
  final (top-most) =step= is the value of the =ind-Nat= expression.

The workings of =ind-Nat= are best illustrated by example.

* Exercises

Suppose want to define a function that returns a specific number of =’peas=. We
could define the function to return a =(List Atom)= like this:

#+begin_src racket :tangle list-of-peas.rkt :lang pie

#lang pie

(claim step-list-of-peas
  (-> Nat (List Atom)
      (List Atom)))

(define step-list-of-peas
  (lambda (k-1 answer-k-1)
    (:: 'pea answer-k-1)))

(claim list-of-peas
  (-> Nat (List Atom)))

(define list-of-peas
  (lambda (k)
    (rec-Nat k
      (the (List Atom) nil)
      step-list-of-peas)))

(check-same (List Atom)
  (:: 'pea nil)
  (list-of-peas 1))

(check-same (List Atom)
  (the (List Atom) nil)
  (list-of-peas 0))

#+end_src

Using a list works in this case, but is unsatisfying because the type doesn’t
describe /how many/ peas are returned. What if we modify the code to use a
Vector instead?

#+begin_src racket :tangle failed-attempt.rkt :lang pie

#lang pie

(claim vec-of-peas
  (Π ((k Nat))
     (Vec Atom k)))

(define vec-of-peas
  (λ (k)
    (rec-Nat k
      (the (Vec Atom zero) vecnil)
      (λ (k-1 ans-k-1)
        (the (Vec Atom (add1 k-1))
             (vec:: 'pea ans-k-1))))))

#+end_src

This definition /seems/ like it should work, but results in an error because
=rec-Nat= isn’t able to work with dependent types. Now we’ll see how =ind-Nat=
allows us to specify the different specific types returned by the base and each
step.

The first objective is to define the motive. Here’s how we can reason about the
claim and definition of the motive, which we’ll call =motive-peas=. The motive
is a function that will be applied to the target and return the *type* of the
=ind-Nat= expression. The overall =peas= function is intended to return a
=Vector= of Atoms, and the Vector type describes the exact length of the Vector.
So we can reason that the motive will require a specific =Nat= describing the
length of the Vector and will return a /type/ that is a Vector of that length.
In order to incorporate the specific =Nat=, we’ll introduce a binding for it in
the claim with a =\Pi= expression.

#+begin_src racket :tangle peas.rkt :lang pie

  #lang pie

  (claim motive-peas
    (Π ((l Nat))
       U))

  (define motive-peas
    (λ (l)
      (Vec Atom l)))

#+end_src

Notice that the motive returns the type =(Vec Atom zero)= if we call =(peas 0)=.
Since the only =(Vec Atom zero)= is =vecnil=, we already know that will be the
=base= in the =ind-Nat= expression as well as the overall return value for
=(peas 0)=. At this point, we know the =target=, =motive=, and =base= of the
=ind-Nat= expression, leaving only the =step= to figure out.

The step function for =ind-Nat= behaves just as the step function for =rec-Nat=
which means that it will receive two arguments when the target is =(the Nat
(add1 k))=. The first argument will be =(the Nat k)= (eliminating an =add1=),
and the second argument will be the recursive result of the step function for
=(the Nat k)=.

We can discover the correct implementation of =step-peas= by reasoning about a
simple case. Let’s assume we’re computing the value of =(peas two)= which is
=(peas (add1 (add1 zero)))=. This means the =target= of the =ind-Nat= expression
is =two=. We know that the step function will be given two arguments =(add1
zero)= and =(vec:: ’pea vecnil)=. The implementation of the step function must
clearly use the =vec::= constructor to tack another =’pea= onto the recursive
result.

The claim is the tricky part. We know that we will need the value of the
=Nat= to be used in the type definition, so we will need a =\Pi= expression. Since
step is a function, we know the claim returns a function type. But how do we
specify the type of the arguments and return value? It turns out we’ve already
done that work. Both the second argument and the return value are the result of
the step function. The point of introducing the =motive= was to calculate the
result of the step function, so we /invoke/ the motive in the claim to find the
right type!

#+begin_src racket :tangle peas.rkt :lang pie

  (claim step-peas
    (Π ((l-1 Nat))
       (-> (motive-peas l-1)
           (motive-peas (add1 l-1)))))

  (define step-peas
    (λ (l-1)
      (λ (answer-l-1)
        (vec:: 'pea answer-l-1))))

#+end_src

With all of the parts of the =ind-Nat= expression defined, it’s trivial to
stitch them together and check our work.

#+begin_src racket :tangle peas.rkt :lang pie

  (claim peas
    (Π ((l Nat))
       (Vec Atom l)))

  (define peas
    (λ (l)
      (ind-Nat l
        motive-peas
        vecnil
        step-peas)))

  (check-same
   (Vec Atom 5)
   (the (Vec Atom 5)
        (vec:: 'pea
               (vec:: 'pea
                      (vec:: 'pea
                             (vec:: 'pea
                                    (vec:: 'pea vecnil))))))
   (peas 5))
#+end_src

Now we can move on to something slightly more complex. In this section, we will
implement the =last= function, which returns the last element of a vector of any
type. There is an interesting tension that we have to resolve. The first is that
all functions in Pie must be /total/ functions.

#+begin_src racket :tangle last.rkt :lang pie
  (claim motive-last
    (-> U Nat
        U))

  (define motive-last
    (λ (E k)
      (-> (Vec E (add1 k))
          E)))

  (claim base-last
    (Π ((E U))
       (-> (Vec E (add1 zero))
           E)))

  (define base-last
    (λ (E)
      (λ (es)
        (head es))))

  (claim step-last
    (Π ((E U)
        (k Nat))
       (-> (-> (Vec E (add1 k)) E)
           (-> (Vec E (add1 (add1 k)))
               E))))

  (define step-last
    (λ (E)
      (λ (n-1 last-of-n-1)
        (λ (es)
          (last-of-n-1 (tail es))))))

  (claim last
    (Π ((E U)
        (k Nat))
       (-> (Vec E (add1 k))
           E)))

  (define last
    (λ (E k)
      (λ (es)
        ((ind-Nat k
           (motive-last E)
           (base-last E)
           (step-last E)) es))))

  (check-same
   Atom
   'Done
   (last Atom 0 (vec:: 'Done vecnil)))

  (check-same
   Atom
   'Coming
   (last Atom 2 (vec:: 'Winter (vec:: 'Is (vec:: 'Coming  vecnil)))))
#+end_src
