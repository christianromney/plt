* Dependent Types
A dependent type is *a type that is defined by something that is not a type*.

** Induction on Natural Numbers
 - Induction involves a proof of N=0, then of N+1
 - In Pie, induction on Nat uses the form =ind-Nat=

#+begin_example

(ind-Nat target
  motive
  base
  step)

#+end_example

=ind-Nat= behaves like =rec-Nat= except that we can use it with
dependent types. This means that base and step return different
dependent types. =ind-Nat=

- =target= : the initial =Nat=
- =motive= : a function that is applied to the target at each step to
  determine the type returned by that step, or the base when the
  target is =zero=
- =base= : the value to return when the =target= is =zero=
- =step= : a function that accepts the value under the =add1= and the
  recursive result of the computation at that step. The value of the
  final (top-most) =step= is the value of the =ind-Nat= expression.

The workings of =ind-Nat= are best illustrated by example.

** Exercises
Let’s define the function =peas= which returns a specified number of peas.

#+BEGIN_SRC racket :tangle yes :lang pie
  #lang pie

  (claim motive-peas
    (Π ((l Nat))
       U))

  (define motive-peas
    (λ (l)
      (Vec Atom l)))

  (claim step-peas
    (Π ((l-1 Nat))
       (-> (motive-peas l-1)
           (motive-peas (add1 l-1)))))

  (define step-peas
    (λ (l-1)
      (λ (answer-l-1)
        (vec:: 'pea answer-l-1))))

  (claim peas
    (Π ((l Nat))
       (Vec Atom l)))

  (define peas
    (λ (l)
      (ind-Nat l
        motive-peas
        vecnil
        step-peas)))

  (check-same
   (Vec Atom 5)
   (the (Vec Atom 5)
        (vec:: 'pea
               (vec:: 'pea
                      (vec:: 'pea
                             (vec:: 'pea
                                    (vec:: 'pea vecnil))))))
   (peas 5))
#+END_SRC

Let’s write the =last= function, which returns the last element of a vector of
any type.

#+begin_src racket :lang pie :tangle yes
  (claim motive-last
    (-> U Nat
        U))

  (define motive-last
    (λ (E k)
      (-> (Vec E (add1 k))
          E)))

  (claim base-last
    (Π ((E U))
       (-> (Vec E (add1 zero))
           E)))

  (define base-last
    (λ (E)
      (λ (es)
        (head es))))

  (claim step-last
    (Π ((E U)
        (k Nat))
       (-> (-> (Vec E (add1 k)) E)
           (-> (Vec E (add1 (add1 k)))
               E))))

  (define step-last
    (λ (E)
      (λ (n-1 last-of-n-1)
        (λ (es)
          (last-of-n-1 (tail es))))))

  (claim last
    (Π ((E U)
        (k Nat))
       (-> (Vec E (add1 k))
           E)))

  (define last
    (λ (E k)
      (λ (es)
        ((ind-Nat k
           (motive-last E)
           (base-last E)
           (step-last E)) es))))

  (check-same
   Atom
   'Done
   (last Atom 0 (vec:: 'Done vecnil)))

  (check-same
   Atom
   'Coming
   (last Atom 2 (vec:: 'Winter (vec:: 'Is (vec:: 'Coming  vecnil)))))
#+end_src
